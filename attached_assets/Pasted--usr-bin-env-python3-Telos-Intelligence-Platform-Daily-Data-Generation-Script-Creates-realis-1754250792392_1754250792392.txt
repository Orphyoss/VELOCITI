#!/usr/bin/env python3
"""
Telos Intelligence Platform - Daily Data Generation Script
Creates realistic, evolving airline intelligence data for application testing

This script acts like a "market simulator" - generating believable competitive moves,
demand shifts, and operational scenarios that your intelligence agents can process.

Usage:
    python daily_data_generator.py --date 2025-08-04 --scenario competitive_attack
    python daily_data_generator.py --auto-scenarios  # Generates realistic random scenarios
"""

import argparse
import asyncio
import asyncpg
import pandas as pd
import numpy as np
from datetime import datetime, date, timedelta
from typing import Dict, List, Optional, Tuple
import json
import logging
import random
from dataclasses import dataclass
from enum import Enum
import os

# ============================================================================
# SCENARIO FRAMEWORK
# ============================================================================

class ScenarioType(str, Enum):
    COMPETITIVE_ATTACK = "competitive_attack"
    DEMAND_SURGE = "demand_surge" 
    OPERATIONAL_DISRUPTION = "operational_disruption"
    ECONOMIC_SHOCK = "economic_shock"
    SEASONAL_SHIFT = "seasonal_shift"
    SYSTEM_ANOMALY = "system_anomaly"
    NORMAL_OPERATIONS = "normal_operations"

@dataclass
class MarketScenario:
    """Defines a realistic market scenario to simulate"""
    scenario_type: ScenarioType
    description: str
    affected_routes: List[str]
    duration_days: int
    intensity: float  # 0.1 = minor, 1.0 = major
    triggers: Dict[str, any]

# ============================================================================
# DAILY DATA GENERATOR ENGINE
# ============================================================================

class TelosDailyDataGenerator:
    """
    Generates realistic airline intelligence data for each day
    Maintains continuity while introducing realistic market dynamics
    """
    
    def __init__(self, db_connection_string: str):
        self.db_connection_string = db_connection_string
        self.logger = logging.getLogger(__name__)
        
        # Core routes for EasyJet focus
        self.core_routes = [
            'LGW-BCN', 'LGW-MAD', 'LGW-CDG', 'LGW-FCO', 'LGW-AMS', 
            'LGW-PMI', 'LGW-AGP', 'STN-BCN', 'LTN-BCN'
        ]
        
        # Carrier ecosystem
        self.carriers = {
            'EZY': {'name': 'EasyJet', 'type': 'LCC', 'aggressiveness': 0.6},
            'RYR': {'name': 'Ryanair', 'type': 'ULCC', 'aggressiveness': 0.9},
            'BA': {'name': 'British Airways', 'type': 'FSC', 'aggressiveness': 0.3},
            'VY': {'name': 'Vueling Airlines', 'type': 'LCC', 'aggressiveness': 0.7},
            'TUI': {'name': 'TUI Airways', 'type': 'LCC', 'aggressiveness': 0.4}
        }
        
        # Scenario probability weights by day of week
        self.scenario_weights = {
            0: {'competitive_attack': 0.15, 'demand_surge': 0.10, 'normal_operations': 0.60},  # Monday
            1: {'competitive_attack': 0.20, 'system_anomaly': 0.10, 'normal_operations': 0.55},  # Tuesday  
            2: {'operational_disruption': 0.15, 'demand_surge': 0.15, 'normal_operations': 0.55},  # Wednesday
            3: {'competitive_attack': 0.25, 'seasonal_shift': 0.10, 'normal_operations': 0.50},  # Thursday
            4: {'economic_shock': 0.10, 'demand_surge': 0.20, 'normal_operations': 0.50},  # Friday
            5: {'operational_disruption': 0.10, 'demand_surge': 0.25, 'normal_operations': 0.45},  # Saturday
            6: {'competitive_attack': 0.10, 'seasonal_shift': 0.15, 'normal_operations': 0.60}   # Sunday
        }
        
        # Memory of recent scenarios to avoid repetition
        self.recent_scenarios = []
        
    async def generate_daily_data(self, target_date: date, scenario: Optional[ScenarioType] = None) -> Dict[str, int]:
        """
        Generate a full day's worth of realistic airline intelligence data
        Returns counts of records generated by table
        """
        
        # Determine scenario for the day
        if scenario is None:
            scenario = self._select_realistic_scenario(target_date)
        
        scenario_config = self._create_scenario_config(scenario, target_date)
        
        self.logger.info(f"Generating data for {target_date} with scenario: {scenario.value}")
        
        async with asyncpg.connect(self.db_connection_string) as conn:
            record_counts = {}
            
            # Generate data in logical order (dependencies matter)
            record_counts['competitive_pricing'] = await self._generate_competitive_pricing(
                conn, target_date, scenario_config
            )
            
            record_counts['market_capacity'] = await self._generate_market_capacity(
                conn, target_date, scenario_config
            )
            
            record_counts['web_search_data'] = await self._generate_web_search_data(
                conn, target_date, scenario_config
            )
            
            record_counts['rm_pricing_actions'] = await self._generate_rm_pricing_actions(
                conn, target_date, scenario_config
            )
            
            record_counts['flight_performance'] = await self._generate_flight_performance(
                conn, target_date, scenario_config
            )
            
            record_counts['market_events'] = await self._generate_market_events(
                conn, target_date, scenario_config
            )
            
            record_counts['economic_indicators'] = await self._generate_economic_indicators(
                conn, target_date, scenario_config
            )
            
            record_counts['intelligence_insights'] = await self._generate_intelligence_insights(
                conn, target_date, scenario_config
            )
            
            # Log processing completion
            await self._log_nightshift_processing(conn, target_date, scenario_config)
            
            # Update scenario memory
            self._update_scenario_memory(scenario, target_date)
            
        return record_counts
    
    def _select_realistic_scenario(self, target_date: date) -> ScenarioType:
        """Select scenario based on day of week, recent history, and seasonality"""
        
        day_of_week = target_date.weekday()
        weights = self.scenario_weights.get(day_of_week, self.scenario_weights[0])
        
        # Adjust weights based on recent scenarios (avoid repetition)
        recent_scenario_types = [s['type'] for s in self.recent_scenarios[-3:]]
        for recent_type in recent_scenario_types:
            if recent_type in weights:
                weights[recent_type] *= 0.5  # Reduce probability of repeating
        
        # Seasonal adjustments
        month = target_date.month
        if month in [6, 7, 8]:  # Summer peak
            weights['demand_surge'] = weights.get('demand_surge', 0) * 1.5
            weights['seasonal_shift'] = weights.get('seasonal_shift', 0) * 2.0
        elif month in [11, 12, 1]:  # Winter/Holiday
            weights['operational_disruption'] = weights.get('operational_disruption', 0) * 1.3
        
        # Normalize weights
        total_weight = sum(weights.values())
        normalized_weights = {k: v/total_weight for k, v in weights.items()}
        
        # Select scenario
        rand = random.random()
        cumulative = 0
        for scenario_name, weight in normalized_weights.items():
            cumulative += weight
            if rand <= cumulative:
                return ScenarioType(scenario_name)
        
        return ScenarioType.NORMAL_OPERATIONS
    
    def _create_scenario_config(self, scenario: ScenarioType, target_date: date) -> MarketScenario:
        """Create detailed configuration for the selected scenario"""
        
        if scenario == ScenarioType.COMPETITIVE_ATTACK:
            return MarketScenario(
                scenario_type=scenario,
                description="Ryanair launches aggressive pricing campaign",
                affected_routes=random.sample(self.core_routes, random.randint(2, 4)),
                duration_days=random.randint(2, 7),
                intensity=0.7 + random.random() * 0.3,  # 70-100% intensity
                triggers={
                    'competitor': 'RYR',
                    'price_reduction_pct': 15 + random.randint(0, 15),  # 15-30% reduction
                    'routes_affected': 'multiple',
                    'trigger_reason': random.choice([
                        'load_factor_protection', 'market_share_grab', 'yield_optimization'
                    ])
                }
            )
            
        elif scenario == ScenarioType.DEMAND_SURGE:
            return MarketScenario(
                scenario_type=scenario,
                description="Viral social media drives unexpected demand surge",
                affected_routes=[random.choice(['LGW-AGP', 'LGW-PMI', 'LGW-BCN'])],
                duration_days=random.randint(3, 8),
                intensity=0.8 + random.random() * 0.2,
                triggers={
                    'demand_multiplier': 2.0 + random.random() * 1.5,  # 2x-3.5x normal
                    'conversion_boost': 0.3 + random.random() * 0.2,   # 30-50% higher conversion
                    'trigger_source': random.choice([
                        'social_media_viral', 'celebrity_endorsement', 'travel_blogger', 'news_event'
                    ])
                }
            )
            
        elif scenario == ScenarioType.OPERATIONAL_DISRUPTION:
            return MarketScenario(
                scenario_type=scenario,
                description="French ATC strike disrupts European operations",
                affected_routes=['LGW-CDG', 'LGW-ORY'] + random.sample(self.core_routes, 2),
                duration_days=random.randint(1, 3),
                intensity=0.6 + random.random() * 0.4,
                triggers={
                    'disruption_type': random.choice(['atc_strike', 'weather', 'technical_fault']),
                    'capacity_reduction_pct': 40 + random.randint(0, 30),  # 40-70% reduction
                    'spillover_demand': True,
                    'alternative_routes': ['LGW-AMS', 'LGW-BRU']
                }
            )
            
        elif scenario == ScenarioType.ECONOMIC_SHOCK:
            return MarketScenario(
                scenario_type=scenario,
                description="Currency volatility impacts European travel demand",
                affected_routes=self.core_routes,  # Affects all routes
                duration_days=random.randint(5, 14),
                intensity=0.4 + random.random() * 0.4,
                triggers={
                    'currency_movement_pct': 3 + random.random() * 5,  # 3-8% movement
                    'direction': random.choice(['gbp_strength', 'gbp_weakness']),
                    'demand_impact_pct': 5 + random.random() * 10  # 5-15% demand change
                }
            )
            
        elif scenario == ScenarioType.SYSTEM_ANOMALY:
            return MarketScenario(
                scenario_type=scenario,
                description="Revenue management system optimization opportunity",
                affected_routes=random.sample(self.core_routes, random.randint(3, 5)),
                duration_days=1,
                intensity=0.5 + random.random() * 0.3,
                triggers={
                    'system_type': random.choice(['elysium', 'segment_finder', 'manual_override']),
                    'anomaly_type': random.choice([
                        'forecast_deviation', 'booking_curve_shift', 'competitor_blind_spot'
                    ]),
                    'manual_interventions': random.randint(5, 15)
                }
            )
            
        else:  # NORMAL_OPERATIONS or others
            return MarketScenario(
                scenario_type=ScenarioType.NORMAL_OPERATIONS,
                description="Standard market conditions with normal variations",
                affected_routes=self.core_routes,
                duration_days=1,
                intensity=0.3 + random.random() * 0.2,
                triggers={'normal_variance': True}
            )
    
    async def _generate_competitive_pricing(self, conn, target_date: date, scenario: MarketScenario) -> int:
        """Generate competitive pricing data with scenario-driven variations"""
        
        records_inserted = 0
        
        for route in self.core_routes:
            # Generate flight dates (next 30-60 days)
            flight_dates = [target_date + timedelta(days=i) for i in range(14, 45)]
            
            for airline_code, airline_info in self.carriers.items():
                for flight_date in flight_dates:
                    
                    # Base price calculation
                    base_price = self._calculate_base_price(route, airline_code, flight_date, target_date)
                    
                    # Apply scenario effects
                    final_price = self._apply_scenario_to_pricing(
                        base_price, airline_code, route, scenario, target_date
                    )
                    
                    # Skip some records for realism (85% data availability)
                    if random.random() > 0.85:
                        continue
                    
                    # Insert record
                    await conn.execute("""
                        INSERT INTO competitive_pricing (
                            insertdttm, key_comp, sector, observation_dt, carriername,
                            flight_mth, flight_dt, flight_tm, flight_number,
                            price_gbp, price_lct, currencycode, route_id, airline_code, data_source
                        ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15)
                    """, 
                        datetime.now(),  # insertdttm
                        f"{route.replace('-', '')}{target_date.strftime('%Y%m%d')}",  # key_comp
                        route.replace('-', ''),  # sector
                        target_date,  # observation_dt
                        airline_info['name'],  # carriername
                        flight_date.strftime('%m/%y'),  # flight_mth
                        flight_date,  # flight_dt
                        datetime.strptime('08:00', '%H:%M').time() + timedelta(hours=random.randint(0, 14)),  # flight_tm
                        f"{airline_code}{random.randint(1000, 9999)}",  # flight_number
                        round(final_price, 2),  # price_gbp
                        round(final_price * 1.17, 2),  # price_lct (EUR)
                        'EUR',  # currencycode
                        route,  # route_id
                        airline_code,  # airline_code
                        'INFARE'  # data_source
                    )
                    records_inserted += 1
        
        return records_inserted
    
    def _calculate_base_price(self, route: str, airline_code: str, flight_date: date, observation_date: date) -> float:
        """Calculate baseline price before scenario effects"""
        
        # Route-based pricing
        route_multipliers = {
            'LGW-BCN': 1.0, 'LGW-MAD': 1.1, 'LGW-CDG': 0.8, 'LGW-FCO': 1.2,
            'LGW-AMS': 0.9, 'LGW-PMI': 1.3, 'LGW-AGP': 1.1, 'STN-BCN': 0.7, 'LTN-BCN': 0.7
        }
        
        # Carrier-based pricing
        carrier_base_prices = {
            'EZY': 85, 'RYR': 55, 'BA': 150, 'VY': 75, 'TUI': 90
        }
        
        # Days to departure effect
        days_out = (flight_date - observation_date).days
        advance_multiplier = max(0.6, 1.0 - (days_out - 14) * 0.008)  # Cheaper further out
        
        # Seasonal effect
        month = flight_date.month
        seasonal_multiplier = 1.0
        if month in [6, 7, 8]:  # Summer
            seasonal_multiplier = 1.4
        elif month in [4, 5, 9, 10]:  # Shoulder
            seasonal_multiplier = 1.1
        
        # Day of week effect
        dow = flight_date.weekday()
        dow_multiplier = 1.2 if dow in [4, 5, 6] else 1.0  # Weekend premium
        
        base_price = (
            carrier_base_prices[airline_code] * 
            route_multipliers.get(route, 1.0) * 
            advance_multiplier * 
            seasonal_multiplier * 
            dow_multiplier
        )
        
        # Add random variation
        base_price *= (0.9 + random.random() * 0.2)  # ±10% random variation
        
        return base_price
    
    def _apply_scenario_to_pricing(self, base_price: float, airline_code: str, route: str, 
                                 scenario: MarketScenario, observation_date: date) -> float:
        """Apply scenario-specific effects to pricing"""
        
        if scenario.scenario_type == ScenarioType.COMPETITIVE_ATTACK:
            if (airline_code == scenario.triggers.get('competitor') and 
                route in scenario.affected_routes):
                # Aggressive price reduction
                reduction_pct = scenario.triggers.get('price_reduction_pct', 20) / 100
                return base_price * (1 - reduction_pct)
            elif route in scenario.affected_routes:
                # Other carriers might respond or hold firm
                if random.random() < 0.3:  # 30% chance of response
                    return base_price * 0.92  # Modest response
        
        elif scenario.scenario_type == ScenarioType.DEMAND_SURGE:
            if route in scenario.affected_routes:
                # Higher demand allows price increases
                surge_multiplier = min(1.3, 1.0 + scenario.intensity * 0.2)
                return base_price * surge_multiplier
        
        elif scenario.scenario_type == ScenarioType.OPERATIONAL_DISRUPTION:
            if route in scenario.affected_routes:
                # Disrupted routes might see price increases due to scarcity
                return base_price * (1.1 + scenario.intensity * 0.1)
            elif route in scenario.triggers.get('alternative_routes', []):
                # Alternative routes see demand spillover = higher prices
                return base_price * 1.15
        
        elif scenario.scenario_type == ScenarioType.ECONOMIC_SHOCK:
            # Currency effects impact all routes
            direction = scenario.triggers.get('direction')
            impact_pct = scenario.triggers.get('currency_movement_pct', 5) / 100
            
            if direction == 'gbp_strength':
                # Stronger GBP makes travel more expensive for Europeans
                return base_price * (1 + impact_pct * 0.5)
            else:
                # Weaker GBP makes travel cheaper
                return base_price * (1 - impact_pct * 0.3)
        
        return base_price
    
    async def _generate_web_search_data(self, conn, target_date: date, scenario: MarketScenario) -> int:
        """Generate web search and demand data with scenario effects"""
        
        records_inserted = 0
        
        for route in self.core_routes:
            # Base search volume
            base_searches = self._calculate_base_search_volume(route, target_date)
            base_bookings = int(base_searches * (0.09 + random.random() * 0.04))  # 9-13% conversion
            
            # Apply scenario effects
            final_searches, final_bookings = self._apply_scenario_to_demand(
                base_searches, base_bookings, route, scenario
            )
            
            # Last year comparison (slightly lower)
            ly_searches = int(final_searches * (0.85 + random.random() * 0.2))
            ly_bookings = int(ly_searches * (0.08 + random.random() * 0.03))
            
            conversion_rate = final_bookings / final_searches if final_searches > 0 else 0.10
            
            await conn.execute("""
                INSERT INTO web_search_data (
                    insertdttm, key_web, sector, flight_mth, search_dt,
                    web_ty_searches, web_ty_bookings, web_ly_searches, web_ly_bookings,
                    conversion_rate, route_id, data_source
                ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12)
            """,
                datetime.now(),  # insertdttm
                f"{route.replace('-', '')}{target_date.strftime('%Y%m%d')}",  # key_web
                route.replace('-', ''),  # sector
                (target_date + timedelta(days=30)).strftime('%m/%y'),  # flight_mth
                target_date,  # search_dt
                final_searches,  # web_ty_searches
                final_bookings,  # web_ty_bookings
                ly_searches,  # web_ly_searches  
                ly_bookings,  # web_ly_bookings
                round(conversion_rate, 4),  # conversion_rate
                route,  # route_id
                'SKYSCANNER'  # data_source
            )
            records_inserted += 1
        
        return records_inserted
    
    def _calculate_base_search_volume(self, route: str, search_date: date) -> int:
        """Calculate baseline search volume for route"""
        
        # Route popularity
        route_base_volumes = {
            'LGW-BCN': 800, 'LGW-MAD': 600, 'LGW-CDG': 500, 'LGW-FCO': 700,
            'LGW-AMS': 550, 'LGW-PMI': 900, 'LGW-AGP': 650, 'STN-BCN': 400, 'LTN-BCN': 350
        }
        
        base_volume = route_base_volumes.get(route, 500)
        
        # Seasonal adjustment
        month = search_date.month
        if month in [3, 4, 5]:  # Spring booking season
            base_volume *= 1.3
        elif month in [6, 7, 8]:  # Summer peak
            base_volume *= 1.5
        elif month in [1, 2]:  # Winter lull
            base_volume *= 0.7
        
        # Day of week effect (people search more on weekends)
        dow = search_date.weekday()
        if dow in [5, 6]:  # Weekend
            base_volume *= 1.2
        
        # Add random variation
        base_volume = int(base_volume * (0.8 + random.random() * 0.4))
        
        return base_volume
    
    def _apply_scenario_to_demand(self, base_searches: int, base_bookings: int, 
                                route: str, scenario: MarketScenario) -> Tuple[int, int]:
        """Apply scenario effects to search and booking volumes"""
        
        if scenario.scenario_type == ScenarioType.DEMAND_SURGE:
            if route in scenario.affected_routes:
                multiplier = scenario.triggers.get('demand_multiplier', 2.0)
                conversion_boost = scenario.triggers.get('conversion_boost', 0.3)
                
                final_searches = int(base_searches * multiplier)
                # Higher conversion rate during surge
                base_conversion = base_bookings / base_searches if base_searches > 0 else 0.10
                boosted_conversion = min(0.25, base_conversion * (1 + conversion_boost))
                final_bookings = int(final_searches * boosted_conversion)
                
                return final_searches, final_bookings
        
        elif scenario.scenario_type == ScenarioType.COMPETITIVE_ATTACK:
            if route in scenario.affected_routes:
                # Competitive pricing might increase search interest
                search_boost = 1.0 + scenario.intensity * 0.15
                return int(base_searches * search_boost), base_bookings
        
        elif scenario.scenario_type == ScenarioType.OPERATIONAL_DISRUPTION:
            if route in scenario.affected_routes:
                # Disruption reduces searches for affected routes
                disruption_factor = 1 - (scenario.intensity * 0.4)
                return int(base_searches * disruption_factor), int(base_bookings * disruption_factor)
            elif route in scenario.triggers.get('alternative_routes', []):
                # Alternative routes get spillover searches
                spillover_factor = 1.2 + scenario.intensity * 0.3
                return int(base_searches * spillover_factor), int(base_bookings * spillover_factor)
        
        return base_searches, base_bookings
    
    async def _generate_rm_pricing_actions(self, conn, target_date: date, scenario: MarketScenario) -> int:
        """Generate revenue management pricing actions"""
        
        records_inserted = 0
        
        # Normal day: 20-30% of routes have some RM action
        # High scenario intensity: up to 60% of routes
        action_probability = 0.25 + (scenario.intensity * 0.35)
        
        for route in self.core_routes:
            if random.random() > action_probability:
                continue
            
            # Generate 1-3 actions per route
            num_actions = random.choices([1, 2, 3], weights=[60, 30, 10])[0]
            
            for _ in range(num_actions):
                flight_date = target_date + timedelta(days=random.randint(15, 45))
                
                # Determine action type based on scenario
                action_type, change_reason = self._determine_rm_action(route, scenario)
                
                await conn.execute("""
                    INSERT INTO rm_pricing_actions (
                        insertdttm, key_price, sector, flightkey, flight_dt, flight_mth,
                        observation_dt, ty_ticketprice_local, ty_ticketprice_gbp,
                        ty_ticketprice_currencycode, action_type, change_reason, change_source,
                        distance_from_profile, booking_curve_position, route_id
                    ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16)
                """,
                    datetime.now(),  # insertdttm
                    f"{route.replace('-', '')}{target_date.strftime('%Y%m%d')}",  # key_price
                    route.replace('-', ''),  # sector
                    f"EZY{random.randint(1000, 9999)}{flight_date.strftime('%y%m%d')}",  # flightkey
                    flight_date,  # flight_dt
                    flight_date.strftime('%m/%y'),  # flight_mth
                    target_date,  # observation_dt
                    round(80 + random.random() * 60, 2),  # ty_ticketprice_local
                    round(80 + random.random() * 60, 2),  # ty_ticketprice_gbp
                    'GBP',  # ty_ticketprice_currencycode
                    action_type,  # action_type
                    change_reason,  # change_reason
                    random.choice(['Elysium', 'Segment_Finder', 'Manual']),  # change_source
                    round(-0.3 + random.random() * 0.6, 4),  # distance_from_profile (-30% to +30%)
                    round(20 + random.random() * 50, 2),  # booking_curve_position
                    route  # route_id
                )
                records_inserted += 1
        
        return records_inserted
    
    def _determine_rm_action(self, route: str, scenario: MarketScenario) -> Tuple[str, str]:
        """Determine RM action type and reason based on scenario"""
        
        if scenario.scenario_type == ScenarioType.COMPETITIVE_ATTACK:
            if route in scenario.affected_routes:
                if random.random() < 0.7:
                    return 'price_decrease', 'competitor_response'
                else:
                    return 'inventory_adjust', 'load_factor_protection'
        
        elif scenario.scenario_type == ScenarioType.DEMAND_SURGE:
            if route in scenario.affected_routes:
                if random.random() < 0.8:
                    return 'price_increase', 'demand_optimization'
                else:
                    return 'inventory_adjust', 'capacity_constraint'
        
        elif scenario.scenario_type == ScenarioType.SYSTEM_ANOMALY:
            # More manual interventions during system anomalies
            if random.random() < 0.6:
                return random.choice(['price_increase', 'price_decrease']), 'analyst_manual'
            else:
                return 'inventory_adjust', 'system_correction'
        
        # Normal operations
        action_types = ['price_increase', 'price_decrease', 'inventory_adjust']
        reasons = ['system_auto', 'forecast_update', 'booking_curve_adjustment']
        
        return random.choice(action_types), random.choice(reasons)
    
    async def _generate_flight_performance(self, conn, target_date: date, scenario: MarketScenario) -> int:
        """Generate flight performance data for flights that operated yesterday"""
        
        performance_date = target_date - timedelta(days=1)  # Yesterday's performance
        records_inserted = 0
        
        for route in self.core_routes:
            # EasyJet typically operates 1-3 flights per day on core routes
            num_flights = random.choices([1, 2, 3], weights=[30, 50, 20])[0]
            
            for flight_num in range(num_flights):
                # Base performance metrics
                total_seats = 180  # A320 standard
                base_load_factor = self._calculate_base_load_factor(route, performance_date)
                
                # Apply scenario effects
                final_load_factor = self._apply_scenario_to_performance(
                    base_load_factor, route, scenario
                )
                
                bookings_count = int(total_seats * (final_load_factor / 100))
                bookings_count = max(0, min(total_seats, bookings_count))
                
                # Revenue calculation
                avg_yield = 85 + random.random() * 40  # €85-125 average yield
                revenue_total = bookings_count * avg_yield
                ancillary_revenue = bookings_count * (18 + random.random() * 12)  # €18-30 per pax
                
                await conn.execute("""
                    INSERT INTO flight_performance (
                        insert_date, performance_date, flight_date, route_id, flight_number,
                        aircraft_type, total_seats, bookings_count, load_factor,
                        revenue_total, revenue_currency, yield_per_pax, ancillary_revenue,
                        no_shows, denied_boardings, days_to_departure
                    ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16)
                """,
                    datetime.now(),  # insert_date
                    target_date,  # performance_date
                    performance_date,  # flight_date
                    route,  # route_id
                    f"EZY{random.randint(1000, 9999)}",  # flight_number
                    'A320',  # aircraft_type
                    total_seats,  # total_seats
                    bookings_count,  # bookings_count
                    round(final_load_factor, 1),  # load_factor
                    round(revenue_total, 2),  # revenue_total
                    'EUR',  # revenue_currency
                    round(avg_yield, 2),  # yield_per_pax
                    round(ancillary_revenue, 2),  # ancillary_revenue
                    random.randint(3, 12),  # no_shows
                    0 if final_load_factor < 95 else random.randint(0, 3),  # denied_boardings
                    0  # days_to_departure (flight already operated)
                )
                records_inserted += 1
        
        return records_inserted
    
    def _calculate_base_load_factor(self, route: str, flight_date: date) -> float:
        """Calculate baseline load factor for route"""
        
        # Route performance baselines
        route_base_lf = {
            'LGW-BCN': 82, 'LGW-MAD': 78, 'LGW-CDG': 75, 'LGW-FCO': 85,
            'LGW-AMS': 79, 'LGW-PMI': 88, 'LGW-AGP': 83, 'STN-BCN': 72, 'LTN-BCN': 68
        }
        
        base_lf = route_base_lf.get(route, 75)
        
        # Seasonal adjustment
        month = flight_date.month
        if month in [6, 7, 8]:  # Summer peak
            base_lf += 8
        elif month in [4, 5, 9, 10]:  # Shoulder
            base_lf += 3
        elif month in [12, 1]:  # Winter lull
            base_lf -= 5
        
        # Day of week effect
        dow = flight_date.weekday()
        if dow in [4, 5, 6]:  # Weekend premium
            base_lf += 5
        elif dow in [1, 2]:  # Mid-week lower
            base_lf -= 3
        
        # Add random variation
        base_lf += random.randint(-8, 8)
        
        return max(45, min(98, base_lf))  # Realistic bounds
    
    def _apply_scenario_to_performance(self, base_load_factor: float, route: str, scenario: MarketScenario) -> float:
        """Apply scenario effects to load factor performance"""
        
        if scenario.scenario_type == ScenarioType.COMPETITIVE_ATTACK:
            if route in scenario.affected_routes:
                # Competitive pressure might reduce load factors
                impact = scenario.intensity * -5  # Up to -5% load factor
                return max(40, base_load_factor + impact)
        
        elif scenario.scenario_type == ScenarioType.DEMAND_SURGE:
            if route in scenario.affected_routes:
                # High demand boosts load factors
                impact = scenario.intensity * 8  # Up to +8% load factor
                return min(98, base_load_factor + impact)
        
        elif scenario.scenario_type == ScenarioType.OPERATIONAL_DISRUPTION:
            if route in scenario.affected_routes:
                # Disruption reduces performance
                impact = scenario.intensity * -12  # Up to -12% load factor
                return max(30, base_load_factor + impact)
        
        return base_load_factor
    
    async def _generate_market_capacity(self, conn, target_date: date, scenario: MarketScenario) -> int:
        """Generate market capacity data showing all carrier operations"""
        
        records_inserted = 0
        
        for route in self.core_routes:
            for airline_code, airline_info in self.carriers.items():
                
                # Base capacity by carrier type
                if airline_info['type'] == 'FSC':
                    base_flights = 1 if route in ['LGW-CDG', 'LGW-AMS'] else 0
                elif airline_info['type'] == 'ULCC' and airline_code == 'RYR':
                    base_flights = 2 if route in ['LGW-BCN', 'STN-BCN', 'LTN-BCN'] else 1
                elif airline_code == 'EZY':
                    base_flights = 2 if route.startswith('LGW-') else 1
                else:
                    base_flights = 1 if random.random() < 0.6 else 0
                
                # Apply scenario effects to capacity
                final_flights = self._apply_scenario_to_capacity(
                    base_flights, airline_code, route, scenario
                )
                
                if final_flights == 0:
                    continue
                
                # Aircraft type and seats
                aircraft_type = 'A320' if airline_code == 'EZY' else 'B737'
                seats_per_flight = 180 if aircraft_type == 'A320' else 189
                
                await conn.execute("""
                    INSERT INTO market_capacity (
                        insertdttm, key_mcap, sector, flight_dt, flight_mth,
                        carriername, carriertype, num_flights, num_seats,
                        aircraft_type, route_id, airline_code, data_source
                    ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13)
                """,
                    datetime.now(),  # insertdttm
                    f"{route.replace('-', '')}{target_date.strftime('%Y%m%d')}",  # key_mcap
                    route.replace('-', ''),  # sector
                    target_date,  # flight_dt
                    target_date.strftime('%m/%y'),  # flight_mth
                    airline_info['name'],  # carriername
                    airline_info['type'],  # carriertype
                    final_flights,  # num_flights
                    final_flights * seats_per_flight,  # num_seats
                    aircraft_type,  # aircraft_type
                    route,  # route_id
                    airline_code,  # airline_code
                    'OAG'  # data_source
                )
                records_inserted += 1
        
        return records_inserted
    
    def _apply_scenario_to_capacity(self, base_flights: int, airline_code: str, route: str, scenario: MarketScenario) -> int:
        """Apply scenario effects to capacity deployment"""
        
        if scenario.scenario_type == ScenarioType.COMPETITIVE_ATTACK:
            if (airline_code == scenario.triggers.get('competitor') and 
                route in scenario.affected_routes):
                # Aggressive competitor might add capacity
                if random.random() < 0.3:  # 30% chance
                    return base_flights + 1
        
        elif scenario.scenario_type == ScenarioType.OPERATIONAL_DISRUPTION:
            if route in scenario.affected_routes:
                # Disrupted routes lose capacity
                reduction_chance = scenario.triggers.get('capacity_reduction_pct', 50) / 100
                if random.random() < reduction_chance:
                    return max(0, base_flights - 1)
        
        return base_flights
    
    async def _generate_market_events(self, conn, target_date: date, scenario: MarketScenario) -> int:
        """Generate market events based on scenario"""
        
        if scenario.scenario_type == ScenarioType.NORMAL_OPERATIONS:
            return 0  # No special events
        
        event_descriptions = {
            ScenarioType.COMPETITIVE_ATTACK: {
                'event_type': 'Competitive',
                'event_name': f"{scenario.triggers.get('competitor', 'Competitor')} Aggressive Pricing Campaign",
                'impact_description': f"Price reductions of {scenario.triggers.get('price_reduction_pct', 20)}% detected on multiple European routes"
            },
            ScenarioType.DEMAND_SURGE: {
                'event_type': 'Marketing',
                'event_name': f"Viral Social Media Travel Content - {scenario.affected_routes[0]}",
                'impact_description': f"Travel influencer content drives {scenario.triggers.get('demand_multiplier', 2.0):.1f}x normal search volume"
            },
            ScenarioType.OPERATIONAL_DISRUPTION: {
                'event_type': 'Strike',
                'event_name': f"{scenario.triggers.get('disruption_type', 'ATC')} Disruption",
                'impact_description': f"Operations disrupted with {scenario.triggers.get('capacity_reduction_pct', 50)}% flight reductions"
            },
            ScenarioType.ECONOMIC_SHOCK: {
                'event_type': 'Economic',
                'event_name': f"Currency Volatility - {scenario.triggers.get('direction', 'GBP')} Movement",
                'impact_description': f"Exchange rate movement of {scenario.triggers.get('currency_movement_pct', 5)}% impacts European travel demand"
            }
        }
        
        event_info = event_descriptions.get(scenario.scenario_type)
        if not event_info:
            return 0
        
        await conn.execute("""
            INSERT INTO market_events (
                event_date, event_type, event_name, affected_airports, affected_routes,
                impact_level, impact_description, start_date, end_date, data_source
            ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10)
        """,
            target_date,  # event_date
            event_info['event_type'],  # event_type
            event_info['event_name'],  # event_name
            json.dumps([route.split('-')[0] for route in scenario.affected_routes] + 
                      [route.split('-')[1] for route in scenario.affected_routes]),  # affected_airports
            json.dumps(scenario.affected_routes),  # affected_routes
            'High' if scenario.intensity > 0.7 else 'Medium' if scenario.intensity > 0.4 else 'Low',  # impact_level
            event_info['impact_description'],  # impact_description
            target_date,  # start_date
            target_date + timedelta(days=scenario.duration_days),  # end_date
            'Market_Intelligence'  # data_source
        )
        
        return 1
    
    async def _generate_economic_indicators(self, conn, target_date: date, scenario: MarketScenario) -> int:
        """Generate economic indicator data"""
        
        records_inserted = 0
        
        # GBP/EUR Exchange Rate
        base_rate = 1.16  # Base GBP/EUR rate
        
        if scenario.scenario_type == ScenarioType.ECONOMIC_SHOCK:
            movement_pct = scenario.triggers.get('currency_movement_pct', 5) / 100
            direction = scenario.triggers.get('direction')
            
            if direction == 'gbp_strength':
                current_rate = base_rate * (1 + movement_pct)
            else:
                current_rate = base_rate * (1 - movement_pct)
        else:
            # Normal daily variation
            current_rate = base_rate * (0.98 + random.random() * 0.04)
        
        await conn.execute("""
            INSERT INTO economic_indicators (
                indicator_date, indicator_type, indicator_name, value, unit, region, data_source
            ) VALUES ($1, $2, $3, $4, $5, $6, $7)
        """,
            target_date,  # indicator_date
            'Exchange_Rate',  # indicator_type
            'GBP_EUR',  # indicator_name
            round(current_rate, 4),  # value
            'Rate',  # unit
            'EU',  # region
            'ECB'  # data_source
        )
        records_inserted += 1
        
        # Jet Fuel Price
        base_fuel_price = 750  # EUR per tonne
        fuel_variation = random.randint(-50, 50)
        
        await conn.execute("""
            INSERT INTO economic_indicators (
                indicator_date, indicator_type, indicator_name, value, unit, region, data_source
            ) VALUES ($1, $2, $3, $4, $5, $6, $7)
        """,
            target_date,  # indicator_date
            'Fuel_Price',  # indicator_type
            'Jet_Fuel_EUR_Per_Tonne',  # indicator_name
            base_fuel_price + fuel_variation,  # value
            'EUR/Tonne',  # unit
            'EU',  # region
            'Platts'  # data_source
        )
        records_inserted += 1
        
        return records_inserted
    
    async def _generate_intelligence_insights(self, conn, target_date: date, scenario: MarketScenario) -> int:
        """Generate AI insights based on the day's scenario"""
        
        if scenario.scenario_type == ScenarioType.NORMAL_OPERATIONS:
            # Generate 1-2 routine insights
            return await self._generate_routine_insights(conn, target_date)
        
        insights = []
        
        # Scenario-specific insights
        if scenario.scenario_type == ScenarioType.COMPETITIVE_ATTACK:
            insights.extend([
                {
                    'insight_type': 'Alert',
                    'priority_level': 'Critical' if scenario.intensity > 0.8 else 'High',
                    'route_id': scenario.affected_routes[0],
                    'airline_code': scenario.triggers.get('competitor'),
                    'title': f"{scenario.triggers.get('competitor', 'Competitor')} Aggressive Pricing on {scenario.affected_routes[0]}",
                    'description': f"{scenario.triggers.get('competitor')} has reduced prices by {scenario.triggers.get('price_reduction_pct')}% on {', '.join(scenario.affected_routes)}. This represents a significant deviation from normal pricing patterns.",
                    'recommendation': f"Monitor booking pace impact. Consider selective price matching on peak travel days if load factors decline below 75%. Activate competitive response protocol within 4 hours.",
                    'confidence_score': 0.88 + scenario.intensity * 0.08,
                    'agent_source': 'Competitive_Intelligence_Agent'
                },
                {
                    'insight_type': 'Opportunity',
                    'priority_level': 'Medium',
                    'route_id': random.choice([r for r in self.core_routes if r not in scenario.affected_routes]),
                    'airline_code': 'EZY',
                    'title': 'Competitive Distraction Creates Pricing Opportunity',
                    'description': f"While {scenario.triggers.get('competitor')} focuses aggressive pricing on {', '.join(scenario.affected_routes)}, other routes show stable competitive environment.",
                    'recommendation': 'Consider price increases of 5-8% on non-affected routes to capture revenue opportunity while competitor is distracted.',
                    'confidence_score': 0.75 + scenario.intensity * 0.05,
                    'agent_source': 'Performance_Intelligence_Agent'
                }
            ])
        
        elif scenario.scenario_type == ScenarioType.DEMAND_SURGE:
            insights.append({
                'insight_type': 'Opportunity',
                'priority_level': 'High',
                'route_id': scenario.affected_routes[0],
                'airline_code': 'EZY',
                'title': f"Exceptional Demand Surge on {scenario.affected_routes[0]}",
                'description': f"Search volume increased {scenario.triggers.get('demand_multiplier', 2.0):.1f}x normal levels due to {scenario.triggers.get('trigger_source', 'viral content')}. Conversion rates up {scenario.triggers.get('conversion_boost', 0.3)*100:.0f}%.",
                'recommendation': f"Immediate price increase of 12-18% recommended for flights 14-35 days out. Demand strength supports premium capture. Monitor competitive response.",
                'confidence_score': 0.92,
                'agent_source': 'Demand_Intelligence_Agent'
            })
        
        elif scenario.scenario_type == ScenarioType.OPERATIONAL_DISRUPTION:
            insights.extend([
                {
                    'insight_type': 'Alert',
                    'priority_level': 'Critical',
                    'route_id': scenario.affected_routes[0],
                    'airline_code': None,
                    'title': f"{scenario.triggers.get('disruption_type', 'Operational')} Disruption Impact",
                    'description': f"Operations disrupted on {', '.join(scenario.affected_routes)} with {scenario.triggers.get('capacity_reduction_pct')}% capacity reduction expected.",
                    'recommendation': 'Activate irregular operations procedures. Consider temporary capacity reallocation to alternative routes. Monitor passenger rebooking patterns.',
                    'confidence_score': 0.95,
                    'agent_source': 'External_Context_Agent'
                },
                {
                    'insight_type': 'Opportunity',
                    'priority_level': 'Medium',
                    'route_id': scenario.triggers.get('alternative_routes', ['LGW-AMS'])[0],
                    'airline_code': 'EZY',
                    'title': 'Disruption Creates Spillover Demand Opportunity',
                    'description': f"Alternative routes showing 20-30% search volume increase as passengers seek alternatives to disrupted {', '.join(scenario.affected_routes)} services.",
                    'recommendation': 'Increase prices 8-12% on alternative routes to capture spillover demand. Consider temporary frequency increases if aircraft available.',
                    'confidence_score': 0.83,
                    'agent_source': 'Demand_Intelligence_Agent'
                }
            ])
        
        elif scenario.scenario_type == ScenarioType.SYSTEM_ANOMALY:
            insights.append({
                'insight_type': 'Alert',
                'priority_level': 'Medium',
                'route_id': scenario.affected_routes[0],
                'airline_code': 'EZY',
                'title': f"Revenue Management System Calibration Opportunity",
                'description': f"Higher than normal manual interventions detected ({scenario.triggers.get('manual_interventions')} actions). {scenario.triggers.get('system_type', 'System')} may require parameter adjustment.",
                'recommendation': 'Review recent manual overrides for pattern analysis. Consider system recalibration if analyst judgment consistently outperforms automated decisions.',
                'confidence_score': 0.78,
                'agent_source': 'Performance_Intelligence_Agent'
            })
        
        elif scenario.scenario_type == ScenarioType.ECONOMIC_SHOCK:
            insights.append({
                'insight_type': 'Trend',
                'priority_level': 'Medium',
                'route_id': None,
                'airline_code': None,
                'title': f"Currency Movement Impact on European Demand",
                'description': f"{scenario.triggers.get('direction', 'GBP')} movement of {scenario.triggers.get('currency_movement_pct')}% expected to impact travel demand by {scenario.triggers.get('demand_impact_pct')}%.",
                'recommendation': 'Monitor European point-of-sale booking patterns closely. Consider promotional pricing for affected markets or shift marketing spend to domestic UK leisure segments.',
                'confidence_score': 0.74,
                'agent_source': 'External_Context_Agent'
            })
        
        # Insert insights
        records_inserted = 0
        for insight in insights:
            await conn.execute("""
                INSERT INTO intelligence_insights (
                    insight_date, insight_type, priority_level, route_id, airline_code,
                    title, description, recommendation, confidence_score, agent_source,
                    supporting_data, action_taken
                ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12)
            """,
                target_date,  # insight_date
                insight['insight_type'],  # insight_type
                insight['priority_level'],  # priority_level
                insight.get('route_id'),  # route_id
                insight.get('airline_code'),  # airline_code
                insight['title'],  # title
                insight['description'],  # description
                insight['recommendation'],  # recommendation
                insight['confidence_score'],  # confidence_score
                insight['agent_source'],  # agent_source
                json.dumps({'scenario': scenario.scenario_type.value, 'intensity': scenario.intensity}),  # supporting_data
                False  # action_taken
            )
            records_inserted += 1
        
        return records_inserted
    
    async def _generate_routine_insights(self, conn, target_date: date) -> int:
        """Generate routine insights for normal operations days"""
        
        routine_insights = [
            {
                'insight_type': 'Trend',
                'priority_level': 'Low',
                'route_id': random.choice(self.core_routes),
                'airline_code': 'EZY',
                'title': 'Standard Booking Curve Performance',
                'description': 'Route performance tracking within normal parameters. Load factors consistent with seasonal expectations.',
                'recommendation': 'Continue monitoring. No immediate action required.',
                'confidence_score': 0.72,
                'agent_source': 'Performance_Intelligence_Agent'
            },
            {
                'insight_type': 'Opportunity',
                'priority_level': 'Low',
                'route_id': random.choice(self.core_routes),
                'airline_code': 'EZY',
                'title': 'Minor Yield Optimization Opportunity',
                'description': 'Booking pace slightly ahead of forecast on selected routes. Window for modest price adjustments.',
                'recommendation': 'Consider 3-5% price increase for flights 21-28 days out.',
                'confidence_score': 0.69,
                'agent_source': 'Performance_Intelligence_Agent'
            }
        ]
        
        # Generate 0-2 routine insights
        num_insights = random.choices([0, 1, 2], weights=[40, 40, 20])[0]
        selected_insights = random.sample(routine_insights, min(num_insights, len(routine_insights)))
        
        records_inserted = 0
        for insight in selected_insights:
            await conn.execute("""
                INSERT INTO intelligence_insights (
                    insight_date, insight_type, priority_level, route_id, airline_code,
                    title, description, recommendation, confidence_score, agent_source,
                    action_taken
                ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11)
            """,
                target_date,
                insight['insight_type'],
                insight['priority_level'],
                insight['route_id'],
                insight['airline_code'],
                insight['title'],
                insight['description'],
                insight['recommendation'],
                insight['confidence_score'],
                insight['agent_source'],
                False
            )
            records_inserted += 1
        
        return records_inserted
    
    async def _log_nightshift_processing(self, conn, target_date: date, scenario: MarketScenario) -> None:
        """Log the NightShift processing run"""
        
        processing_start = datetime.combine(target_date, datetime.min.time()) + timedelta(hours=2)
        processing_duration = timedelta(minutes=35 + random.randint(0, 20))  # 35-55 minutes
        processing_end = processing_start + processing_duration
        
        await conn.execute("""
            INSERT INTO nightshift_processing (
                processing_date, processing_start, processing_end, agent_type,
                routes_processed, insights_generated, alerts_created, processing_status
            ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8)
        """,
            target_date,  # processing_date
            processing_start,  # processing_start
            processing_end,  # processing_end
            'Full_Suite',  # agent_type
            len(self.core_routes),  # routes_processed
            2 if scenario.scenario_type != ScenarioType.NORMAL_OPERATIONS else 1,  # insights_generated
            1 if scenario.intensity > 0.7 else 0,  # alerts_created
            'Completed'  # processing_status
        )
    
    def _update_scenario_memory(self, scenario: ScenarioType, target_date: date) -> None:
        """Update memory of recent scenarios"""
        
        self.recent_scenarios.append({
            'type': scenario.value,
            'date': target_date,
            'intensity': getattr(self, '_last_scenario_intensity', 0.5)
        })
        
        # Keep only last 7 days of scenarios
        self.recent_scenarios = self.recent_scenarios[-7:]

# ============================================================================
# COMMAND LINE INTERFACE
# ============================================================================

async def main():
    """Main execution function"""
    
    parser = argparse.ArgumentParser(description='Generate daily airline intelligence data')
    parser.add_argument('--date', type=str, help='Target date (YYYY-MM-DD)', default=None)
    parser.add_argument('--scenario', type=str, choices=[s.value for s in ScenarioType], 
                       help='Force specific scenario type', default=None)
    parser.add_argument('--auto-scenarios', action='store_true', 
                       help='Generate realistic scenarios automatically')
    parser.add_argument('--backfill-days', type=int, default=0,
                       help='Generate data for N previous days')
    parser.add_argument('--db-url', type=str, required=True,
                       help='Database connection string')
    parser.add_argument('--verbose', action='store_true', help='Verbose logging')
    
    args = parser.parse_args()
    
    # Setup logging
    log_level = logging.DEBUG if args.verbose else logging.INFO
    logging.basicConfig(level=log_level, format='%(asctime)s - %(levelname)s - %(message)s')
    
    # Initialize generator
    generator = TelosDailyDataGenerator(args.db_url)
    
    # Determine dates to process
    if args.date:
        target_date = datetime.strptime(args.date, '%Y-%m-%d').date()
        dates_to_process = [target_date]
    else:
        target_date = date.today()
        dates_to_process = [target_date]
    
    # Add backfill dates
    if args.backfill_days > 0:
        backfill_dates = [target_date - timedelta(days=i) for i in range(1, args.backfill_days + 1)]
        dates_to_process = list(reversed(backfill_dates)) + dates_to_process
    
    # Process each date
    for process_date in dates_to_process:
        print(f"\n{'='*60}")
        print(f"Processing data for {process_date}")
        print(f"{'='*60}")
        
        # Determine scenario
        scenario = None
        if args.scenario:
            scenario = ScenarioType(args.scenario)
        
        try:
            record_counts = await generator.generate_daily_data(process_date, scenario)
            
            print(f"\n📊 Data Generation Complete for {process_date}")
            print(f"{'='*40}")
            
            total_records = sum(record_counts.values())
            for table, count in record_counts.items():
                print(f"  {table:<25}: {count:>6,} records")
            
            print(f"{'='*40}")
            print(f"  {'TOTAL':<25}: {total_records:>6,} records")
            
        except Exception as e:
            print(f"❌ Error generating data for {process_date}: {e}")
            raise

if __name__ == "__main__":
    asyncio.run(main())

# ============================================================================
# USAGE EXAMPLES
# ============================================================================

"""
USAGE EXAMPLES:

# Generate today's data with automatic scenario selection
python daily_data_generator.py --db-url "postgresql://user:pass@host:5432/telos"

# Generate specific date with forced competitive attack scenario
python daily_data_generator.py --date 2025-08-04 --scenario competitive_attack --db-url "postgresql://..."

# Backfill last 7 days with realistic scenarios
python daily_data_generator.py --backfill-days 7 --auto-scenarios --db-url "postgresql://..."

# Generate with verbose logging to see detailed scenario creation
python daily_data_generator.py --verbose --db-url "postgresql://..."

DOCKER DEPLOYMENT:

# Build container
docker buil